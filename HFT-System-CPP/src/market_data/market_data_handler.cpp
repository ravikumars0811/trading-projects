#include "market_data/market_data_handler.hpp"
#include "core/timer.hpp"
#include "core/logger.hpp"
#include <random>

namespace hft {
namespace market_data {

MarketDataHandler::MarketDataHandler() = default;

MarketDataHandler::~MarketDataHandler() {
    stop();
}

void MarketDataHandler::start() {
    if (running_.exchange(true)) {
        return;  // Already running
    }

    processing_thread_ = std::thread(&MarketDataHandler::processingThread, this);
    LOG_INFO("Market data handler started");
}

void MarketDataHandler::stop() {
    if (running_.exchange(false)) {
        if (processing_thread_.joinable()) {
            processing_thread_.join();
        }
        LOG_INFO("Market data handler stopped");
    }
}

void MarketDataHandler::processMessage(const MarketDataMessage& msg) {
    message_queue_.push(msg);
}

void MarketDataHandler::processBatch(const std::vector<MarketDataMessage>& messages) {
    for (const auto& msg : messages) {
        message_queue_.push(msg);
    }
}

const OrderBook* MarketDataHandler::getOrderBook(const std::string& symbol) const {
    auto it = order_books_.find(symbol);
    return (it != order_books_.end()) ? it->second.get() : nullptr;
}

OrderBook* MarketDataHandler::getOrderBook(const std::string& symbol) {
    auto it = order_books_.find(symbol);
    if (it != order_books_.end()) {
        return it->second.get();
    }

    // Create new order book for this symbol
    auto ob = std::make_unique<OrderBook>();
    auto* ptr = ob.get();
    order_books_[symbol] = std::move(ob);

    return ptr;
}

void MarketDataHandler::subscribe(const std::string& symbol, MarketDataCallback callback) {
    callbacks_[symbol] = std::move(callback);
}

void MarketDataHandler::processingThread() {
    while (running_ || !message_queue_.empty()) {
        auto msg_opt = message_queue_.pop();

        if (msg_opt.has_value()) {
            auto& msg = msg_opt.value();

            core::Timer timer;
            int64_t latency_ns = core::Timer::timestamp_ns() - msg.timestamp;

            OrderBook* ob = getOrderBook(msg.symbol);

            switch (msg.type) {
                case MessageType::ORDER_ADD:
                    ob->addOrder(msg.order);
                    break;
                case MessageType::ORDER_MODIFY:
                    ob->modifyOrder(msg.order.order_id, msg.order.quantity);
                    break;
                case MessageType::ORDER_CANCEL:
                    ob->cancelOrder(msg.order.order_id);
                    break;
                case MessageType::TRADE:
                    // Trades are generated by order book matching
                    break;
                case MessageType::SNAPSHOT:
                    // Handle snapshot (not implemented)
                    break;
            }

            // Invoke callback if registered
            auto cb_it = callbacks_.find(msg.symbol);
            if (cb_it != callbacks_.end()) {
                cb_it->second(msg.symbol, *ob);
            }

            updateStatistics(latency_ns);
            messages_processed_++;
        } else {
            // Queue is empty, sleep briefly
            std::this_thread::sleep_for(std::chrono::microseconds(10));
        }
    }
}

void MarketDataHandler::updateStatistics(int64_t latency_ns) {
    // Exponential moving average
    uint64_t current_avg = avg_latency_ns_.load();
    uint64_t new_avg = (current_avg * 95 + latency_ns * 5) / 100;
    avg_latency_ns_.store(new_avg);
}

// Simulated Feed Implementation

SimulatedFeed::SimulatedFeed(MarketDataHandler& handler)
    : handler_(handler) {}

void SimulatedFeed::start() {
    if (running_.exchange(true)) {
        return;
    }

    feed_thread_ = std::thread(&SimulatedFeed::feedThread, this);
    LOG_INFO("Simulated feed started for symbol: ", symbol_);
}

void SimulatedFeed::stop() {
    if (running_.exchange(false)) {
        if (feed_thread_.joinable()) {
            feed_thread_.join();
        }
        LOG_INFO("Simulated feed stopped");
    }
}

void SimulatedFeed::feedThread() {
    std::random_device rd;
    std::mt19937 gen(rd());

    while (running_) {
        auto msg = generateMessage();
        handler_.processMessage(msg);

        std::this_thread::sleep_for(std::chrono::microseconds(tick_interval_us_));
    }
}

MarketDataMessage SimulatedFeed::generateMessage() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> side_dist(0, 1);
    static std::uniform_int_distribution<> price_dist(9900, 10100);
    static std::uniform_int_distribution<> qty_dist(1, 100);
    static std::uniform_int_distribution<> action_dist(0, 100);

    MarketDataMessage msg;
    msg.timestamp = core::Timer::timestamp_ns();
    msg.symbol = symbol_;

    // 80% adds, 10% cancels, 10% modifies
    int action = action_dist(gen);

    if (action < 80) {
        msg.type = MessageType::ORDER_ADD;
        msg.order = Order{
            next_order_id_++,
            static_cast<uint64_t>(price_dist(gen)),
            static_cast<uint32_t>(qty_dist(gen)),
            side_dist(gen) == 0 ? Side::BUY : Side::SELL,
            msg.timestamp
        };
    } else if (action < 90) {
        msg.type = MessageType::ORDER_CANCEL;
        msg.order.order_id = (next_order_id_ > 100) ? next_order_id_ - gen() % 100 : 1;
    } else {
        msg.type = MessageType::ORDER_MODIFY;
        msg.order.order_id = (next_order_id_ > 100) ? next_order_id_ - gen() % 100 : 1;
        msg.order.quantity = qty_dist(gen);
    }

    return msg;
}

} // namespace market_data
} // namespace hft
